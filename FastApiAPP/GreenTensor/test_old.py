import math
import cmath
import scipy
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.ticker as ticker
from scipy.stats import pearsonr
from matplotlib.animation import FFMpegWriter
from matplotlib.colors import Normalize, LogNorm
import time


DN_Ansys_k05_0 = [-0.00155540927079118, -0.00501804918430946, -0.0103876264141705, -0.0176642701454366, -0.026848531343755, -0.0379413819993986, -0.0509442144445386, -0.0658588408534557, -0.0826874930460081, -0.10143282272349, -0.122097902273994, -0.144686226290478, -0.16920171394982, -0.195648712404226, -0.224032001338438, -0.254356798846375, -0.286628768779805, -0.320854029719089, -0.357039165712258, -0.39519123892349, -0.435317804325894, -0.477426926566315, -0.521527199121755, -0.567627765858329, -0.615738345094403, -0.665869256260067, -0.718031449235473, -0.772236536441144, -0.828496827744162, -0.886825368235812, -0.947235978928522, -1.00974330041348, -1.07436283951527, -1.14111101897625, -1.210005230202, -1.28106388909967, -1.35430649504419, -1.42975369301312, -1.50742733893966, -1.58735056834539, -1.66954786833016, -1.75404515301561, -1.84086984256292, -1.93005094591294, -2.02161914743007, -2.11560689766899, -2.21204850852671, -2.31098025309182, -2.41244047055823, -2.51646967663303, -2.62311067993805, -2.73240870498187, -2.84441152236581, -2.95916958698294, -3.07673618507543, -3.19716759113349, -3.32052323574964, -3.44686588568731, -3.57626183758387, -3.70878112688785, -3.84449775383066, -3.98348992845746, -4.12584033699347, -4.27163643210574, -4.42097074994029, -4.57394125717767, -4.73065173176283, -4.89121218143678, -5.0557393047379, -5.22435699976314, -5.39719692669767, -5.57439913095537, -5.75611273474292, -5.94249670599526, -6.13372071496129, -6.32996609028842, -6.53142688831063, -6.73831109144979, -6.95084195427091, -7.16925951888207, -7.39382232516137, -7.62480934587368, -7.86252218230267, -8.10728756280889, -8.3594601950458, -8.61942603282226, -8.88760603131428, -9.16446048018145, -9.45049402403237, -9.74626150480038, -10.0523747925312, -10.3695108120043, -10.6984210254463, -11.0399427004022, -11.3950123822315, -11.7646821106411, -12.1501390804512, -12.5527296647525, -12.9739890176808, -13.415677889786, -13.8798288752304, -14.3688051496845, -14.8853759809535, -15.4328151099548, -16.0150308510421, -16.6367410273337, -17.303712645981, -18.0230973399871, -18.8039124325549, -19.6577505856329, -20.5998618009691, -21.6508690942085, -22.8396206625529, -24.2082153093246, -25.8215301530403, -27.7870845415461, -30.3020779368384, -33.7859647325147, -39.3286705968909, -46.1824083457531, -38.6665791781876, -33.4899906378492, -30.2014299268172, -27.8201136288044, -25.9613415999964, -24.4409702687279, -23.1573827756319, -22.0487505766626, -21.0747120657191, -20.2074870757416, -19.4271506188623, -18.7189327501797, -18.071585690888, -17.4763495325943, -16.9262713914129, -16.4157424340824, -15.9401741897799, -15.4957667395332, -15.0793391817641, -14.6882033279822, -14.3200680466575, -13.9729657469106, -13.6451951270768, -13.3352760548362, -13.0419136213026, -12.7639692199881, -12.5004370670386, -12.2504249807593, -12.013138527759, -11.7878678541698, -11.5739766763296, -11.3708930217702, -11.1781013992268, -10.9951361433304, -10.8215757311154, -10.6570379073678, -10.5011754870197, -10.3536727273404, -10.2142421821307, -10.0826219656584, -9.95857336654984, -9.8418787619267, -9.73233979027788, -9.62977574824773, -9.53402218203023, -9.44492964860547, -9.36236262583399, -9.28619855357999, -9.21632699068404, -9.15264887484305, -9.09507587435512, -9.04352982230991, -8.99794222520132, -8.95825383914885, -8.92441430796973, -8.89638185827471, -8.87412304758818, -8.85761256223874, -8.84683306244535, -8.84177507265241, -8.84243691575668, -8.84882469043192, -8.8609522913049, -8.87884147227862, -8.90252195384606, -8.93203157580103, -8.96741649734236, -9.00873144719565, -9.05604002705675, -9.10941507240663, -9.16893907557624, -9.23470467687241, -9.30681523063329, -9.38538545429498, -9.47054216995101, -9.56242514951524, -9.66118807650657, -9.76699963972084, -9.88004477671829, -10.0005260882281, -10.1286654483719, -10.2647058401858, -10.4089134514614, -10.56158007267, -10.7230258469892, -10.8936024326078, -11.0736966500565, -11.2637347029731, -11.4641870803328, -11.6755742729347, -11.8984734683945, -12.1335264291654, -12.3814488100698, -12.6430412394361, -12.9192025767081, -13.210945877075, -13.5194177513036, -13.8459220224552, -14.1919488738493, -14.5592110891027, -14.9496895576153, -15.3656910378923, -15.8099223626439, -16.2855870356891, -16.796512842638, -17.3473232331684, -17.9436717999539, -18.5925699113069, -19.3028556734228, -20.0858841500412, -20.9565768598482, -21.9350803464205, -23.049511902844, -24.3407715092745, -25.8715996217535, -27.7452723332887, -30.1492037450229, -33.4747114867723, -38.701702720482, -45.5793657632033, -38.7828079593651, -33.4369961430316, -30.024473802846, -27.545473338234, -25.601904956144, -24.0037483693181, -22.6465218375491, -21.4668426682872, -20.4234287263843, -19.4879136980514, -18.6399758347179, -17.8645620267881, -17.1502127675127, -16.4880031632495, -15.8708469824674, -15.2930240951681, -14.749850504198, -14.2374423049485, -13.75254323226, -13.2923962980894, -12.8546466555652, -12.4372669993731, -12.0384995078967, -11.6568101133681, -11.2908520873103, -10.939436753774, -10.6015097195565, -10.2761314198766, -9.96246107259596, -9.65974334894015, -9.36729722726642, -9.08450661479432, -8.81081241148734, -8.54570575824678, -8.28872226380657, -8.03943704518417, -7.7974604481462, -7.562434339013, -7.33402887882725, -7.11193970662642, -6.8958854711699, -6.68560566065552, -6.48085868822843, -6.28142019783702, -6.08708156053055, -5.89764853586354, -5.7129400768597, -5.53278726014169, -5.35703232547183, -5.18552781116443, -5.01813577370083, -4.85472708146168, -4.69518077383868, -4.53938347813766, -4.38722887767066, -4.23861722528188, -4.09345489728321, -3.9516539834081, -3.81313190894048, -3.6778110856539, -3.54561858861145, -3.41648585624154, -3.29034841142203, -3.16714560158467, -3.04682035609567, -2.92931895938303, -2.81459083846907, -2.70258836373165, -2.59326666186203, -2.48658344011365, -2.38249882104662, -2.28097518706902, -2.18197703415926, -2.08547083422695, -1.99142490563112, -1.89980929142926, -1.81059564497557, -1.723757122526, -1.63926828254005, -1.55710499139667, -1.47724433526364, -1.39966453787836, -1.32434488401211, -1.25126564840142, -1.18040802993868, -1.11175409092025, -1.04528670115479, -0.980989486736762, -0.918846783291721, -0.858843593499726, -0.800965548702814, -0.745198874401045, -0.691530359439901, -0.639947328690156, -0.590437619019136, -0.542989558350823, -0.497591947610575, -0.454234045349434, -0.412905554842382, -0.373596613455193, -0.336297784075607, -0.301000048406264, -0.267694801919841, -0.236373850280475, -0.207029407040532, -0.179654092427666, -0.154240933044164, -0.130783362308751, -0.109275221480151, -0.0897107611121882, -0.0720846428012384, -0.0563919410994387, -0.0426281454799613, -0.0307891622547469, -0.0208713163597323, -0.0128713529378774, -0.00678643866601753, -0.00261416278764306, -0.000352537829948328]
DN_Ansys_k05_90 = [-0.000702735439872866, -0.00231397925105224, -0.00483251702104048, -0.00825690901144599, -0.0125855075056486, -0.0178164741476941, -0.0239477971363463, -0.0309773081430129, -0.0389026988281115, -0.0477215368374979, -0.0574312811691725, -0.0680292968098678, -0.0795128685519857, -0.0918792139132153, -0.105125495094009, -0.119248829922041, -0.134246301747319, -0.150114968267209, -0.166851869276454, -0.184454033353796, -0.202918483513334, -0.222242241865449, -0.242422333348604, -0.263455788609325, -0.285339646123077, -0.308070953663201, -0.331646769238255, -0.356064161630142, -0.381320210675236, -0.407412007439177, -0.43433665444177, -0.462091266092189, -0.490672969495496, -0.520078905789886, -0.550306232169282, -0.581352124738465, -0.613213782337061, -0.645888431455396, -0.679373332348376, -0.713665786434453, -0.748763145044493, -0.784662819560985, -0.821362292961324, -0.858859132750477, -0.89715100523819, -0.936235691084914, -0.976111102008835, -1.01677529851438, -1.05822650847099, -1.10046314633996, -1.14348383281765, -1.18728741463529, -1.23187298423026, -1.27723989898044, -1.32338779967362, -1.37031662786725, -1.41802664178153, -1.46651843035983, -1.51579292512634, -1.56585140947093, -1.61669552499545, -1.66832727456521, -1.72074902172224, -1.77396348613556, -1.82797373478476, -1.88278316860007, -1.93839550431092, -1.99481475128852, -2.05204518320368, -2.1100913043598, -2.16895781060168, -2.22864954474367, -2.2891714465046, -2.35052849698189, -2.4127256577433, -2.47576780466024, -2.53965965665275, -2.60440569956115, -2.67001010540436, -2.73647664732781, -2.80380861058666, -2.87200869994986, -2.94107894395009, -3.0110205964413, -3.08183403596004, -3.15351866341984, -3.22607279869765, -3.29949357669901, -3.37377684351351, -3.44891705329419, -3.52490716651347, -3.60173855026422, -3.67940088128682, -3.75788205241256, -3.83716808311836, -3.9172430348896, -3.99808893208448, -4.07968568898614, -4.16201104371683, -4.24504049967078, -4.3287472751012, -4.4131022614682, -4.49807399112249, -4.58362861486006, -4.66972988983921, -4.75633917830112, -4.84341545747897, -4.93091534101995, -5.01879311217719, -5.10700076895792, -5.19548808133741, -5.28420266056884, -5.37309004053555, -5.4620937710062, -5.55115552256585, -5.64021520290668, -5.72921108407365, -5.81807994017234, -5.90675719495998, -5.99517707865729, -6.08327279323947, -6.17097668538889, -6.25822042622274, -6.34493519684422, -6.43105187870899, -6.51650124774711, -6.6012141711376, -6.685121805596, -6.76815579600629, -6.85024847320674, -6.93133304972444, -7.01134381224566, -7.09021630960803, -7.16788753510688, -7.24429610192029, -7.31938241047714, -7.39308880661886, -7.4653597294393, -7.53614184772927, -7.60538418400226, -7.67303822513752, -7.73905801874638, -7.80340025444808, -7.8660243293336, -7.92689239700055, -7.98596939965935, -8.04322308294116, -8.09862399318112, -8.15214545710578, -8.20376354401976, -8.25345701076346, -8.30120722989709, -8.34699810175633, -8.39081595121602, -8.43264941019052, -8.47248928708548, -8.51032842459571, -8.54616154741122, -8.57998510154603, -8.61179708713826, -8.64159688668146, -8.66938509073469, -8.69516332321789, -8.71893406843049, -8.74070050193103, -8.76046632738523, -8.77823562142818, -8.79401268849418, -8.80780192744625, -8.81960771168826, -8.82943428426812, -8.8372856692827, -8.84316560067792, -8.84707746930316, -8.84902428883149, -8.84900868090013, -8.84703287956231, -8.84309875487634, -8.83720785519398, -8.82936146745196, -8.81956069452108, -8.80780654843138, -8.79410005807118, -8.7784423897577, -8.76083497889901, -8.74127967081451, -8.71977886865757, -8.69633568628937, -8.67095410389172, -8.64363912407785, -8.61439692626558, -8.58323501711754, -8.55016237492618, -8.51518958592799, -8.4783289706686, -8.43959469870623, -8.39900289013255, -8.35657170260323, -8.31232140280246, -8.2662744215096, -8.21845539169049, -8.16889116929237, -8.1176108366772, -8.06464568887753, -8.01002920309697, -7.95379699210009, -7.8959867423395, -7.83663813784829, -7.77579277108026, -7.71349404200774, -7.64978704688443, -7.58471845814927, -7.51833639698634, -7.45069030006662, -7.38183078198048, -7.31180949482893, -7.24067898637723, -7.16849255809134, -7.09530412427746, -7.02116807343185, -6.94613913278533, -6.87027223689715, -6.79362240102062, -6.71624459982962, -6.63819365196515, -6.5595241107352, -6.48029016118356, -6.40054552363321, -6.32034336371158, -6.23973620877647, -6.15877587058664, -6.077513373997, -5.99599889140811, -5.91428168266051, -5.832410040038, -5.75043123802734, -5.66839148747698, -5.58633589379997, -5.50430841887834, -5.42235184634457, -5.34050774993998, -5.25881646467907, -5.17731706058115, -5.09604731876568, -5.01504370974378, -4.93434137377559, -4.85397410319889, -4.77397432667029, -4.69437309529306, -4.61520007063683, -4.53648351468291, -4.45825028175294, -4.38052581250096, -4.3033341300661, -4.2266978384969, -4.1506381235688, -4.07517475612186, -4.0003260980487, -3.92610911106096, -3.85253936835794, -3.77963106931301, -3.70739705728184, -3.63584884062256, -3.56499661700089, -3.4948493010342, -3.42541455530701, -3.35669882476726, -3.28870737448777, -3.2214443307517, -3.15491272539343, -3.08911454329913, -3.02405077294322, -2.95972145980929, -2.89612576251664, -2.83326201144683, -2.77112776963932, -2.70971989570047, -2.64903460844855, -2.58906755299606, -2.52981386795332, -2.47126825342127, -2.41342503942927, -2.3562782544639, -2.29982169372881, -2.24404898677291, -2.18895366412488, -2.13452922257663, -2.0807691887662, -2.02766718072203, -1.97521696704576, -1.92341252342854, -1.87224808621731, -1.82171820277112, -1.77181777837415, -1.72254211950022, -1.67388697325373, -1.62584856284316, -1.57842361897531, -1.5316094070909, -1.48540375039458, -1.43980504866406, -1.39481229285444, -1.3504250755432, -1.30664359728976, -1.26346866900959, -1.22090171048736, -1.17894474517515, -1.1376003914415, -1.09687185045376, -1.05676289089085, -1.01727783069501, -0.978421516080779, -0.94019929802619, -0.902617006475902, -0.865680922488649, -0.829397748561964, -0.793774577366223, -0.758818859117506, -0.724538367814902, -0.690941166563083, -0.658035572195112, -0.625830119403922, -0.59433352458397, -0.563554649576979, -0.533502465507961, -0.504186016889861, -0.475614386166975, -0.447796658859264, -0.42074188946149, -0.394459068242913, -0.368957089085041, -0.344244718486704, -0.320330565857339, -0.29722305521088, -0.274930398364072, -0.253460569734207, -0.232821282822235, -0.213019968457898, -0.194063754874, -0.175959449667045, -0.158713523691317, -0.142332096923046, -0.126820926320626, -0.112185395695935, -0.0984305076005535, -0.085560877219684, -0.0735807282550976, -0.0624938907670998, -0.0523038009344549, -0.0430135026800295, -0.0346256510991382, -0.0271425176172095, -0.0205659967932643, -0.0148976146762778, -0.0101385386126129, -0.00628958839444397, -0.00335124863176695, -0.00110846524259226, -0.000276198584961226]
DN_Ansys_k05rog_90 = [-0.000279707314780019, -0.00111450126251139, -0.00250291290652194, -0.00444283375822189, -0.00693152850710439, -0.0099656502634833, -0.0135412581976911, -0.0176538374432656, -0.0222983211165325, -0.0274691142907775, -0.0331601197504151, -0.0393647653394331, -0.0460760327086962, -0.0532864872591019, -0.0609883090720859, -0.069173324615514, -0.0778330390120959, -0.0869586686588909, -0.096541173990482, -0.106571292184876, -0.11703956962026, -0.12793639390216, -0.139252025294361, -0.150976627402737, -0.163100296979024, -0.175613092730761, -0.188505063044354, -0.201766272549564, -0.215386827475668, -0.229356899771422, -0.243666749982366, -0.258306748899493, -0.273267398012282, -0.288539348816443, -0.304113421041436, -0.319980619875195, -0.336132152272612, -0.352559442440529, -0.369254146594251, -0.386208167079975, -0.403413665952708, -0.420863078091491, -0.438549123922345, -0.456464821805033, -0.474603500122766, -0.492958809094548, -0.511524732308758, -0.530295597954221, -0.549266089701739, -0.568431257166021, -0.587786525855139, -0.607327706493189, -0.627051003581892, -0.646953023049447, -0.66703077881997, -0.687281698125419, -0.707703625373691, -0.728294824382485, -0.74905397878806, -0.769980190442112, -0.791072975617531, -0.812332258855911, -0.833758364305009, -0.855352004413529, -0.877114265872504, -0.899046592717527, -0.921150766532944, -0.943428883727803, -0.965883329883286, -0.988516751201714, -1.01133202311799, -1.03433221616439, -1.05752055920901, -1.08090040021634, -1.10447516470444, -1.12824831209799, -1.15222329019817, -1.17640348800998, -1.20079218718479, -1.22539251234988, -1.25020738060848, -1.27523945050267, -1.30049107073777, -1.32596422897071, -1.35166050096635, -1.3775810004252, -1.40372632978317, -1.43009653228012, -1.45669104558752, -1.48350865727886, -1.51054746241785, -1.53780482353006, -1.56527733321359, -1.59296077963328, -1.62085011513171, -1.64893942817795, -1.67722191886272, -1.70568987813559, -1.73433467096668, -1.76314672360144, -1.79211551506309, -1.8212295730427, -1.85047647430166, -1.87984284969591, -1.90931439391475, -1.93887588001044, -1.96851117877664, -1.99820328301574, -2.02793433671512, -2.05768566913226, -2.08743783376696, -2.11717065217604, -2.14686326256232, -2.17649417304398, -2.20604131948433, -2.23548212773384, -2.26479358010723, -2.29395228588776, -2.32293455561932, -2.35171647891386, -2.38027400546799, -2.40858302894786, -2.43661947336639, -2.46435938154177, -2.49177900519069, -2.51885489617596, -2.5455639983944, -2.5718837397598, -2.59779212370645, -2.62326781961276, -2.64829025152206, -2.67283968451981, -2.69689730811352, -2.72044531595456, -2.74346698124069, -2.76594672714401, -2.78787019162323, -2.80922428600063, -2.82999724671378, -2.85017867969009, -2.86975959683841, -2.88873244420577, -2.90709112140948, -2.92483099202286, -2.94194888466871, -2.95844308465442, -2.9743133160686, -2.98956071434654, -3.00418778940347, -3.01819837952528, -3.03159759629783, -3.04439176094551, -3.05658833253516, -3.06819582858427, -3.07922373868792, -3.08968243184897, -3.09958305825802, -3.1089374463233, -3.11775799579516, -3.12605756786512, -3.13384937314422, -3.14114685844094, -3.14796359326376, -3.15431315696891, -3.16020902745952, -3.16566447231924, -3.17069244323121, -3.17530547449413, -3.17951558639976, -3.18333419418347, -3.18677202320013, -3.18983903091464, -3.19254433622859, -3.19489615659378, -3.19690175329099, -3.19856738517703, -3.19989827112855, -3.20089856133486, -3.20157131751716, -3.20191850207751, -3.20194097610817, -3.20163850612172, -3.20100977929442, -3.20005242695059, -3.19876305595457, -3.19713728761933, -3.19516980368799, -3.19285439889587, -3.19018403957784, -3.1871509277475, -3.18374657004278, -3.17996185090665, -3.17578710935151, -3.17121221864299, -3.16622666823201, -3.16081964726446, -3.1549801290047, -3.14869695552306, -3.14195892201787, -3.13475486016922, -3.12707371995466, -3.11890464939528, -3.11023707174367, -3.10106075967354, -3.09136590608113, -3.08114319116327, -3.07038384549205, -3.05907970886318, -3.04722328475096, -3.0348077902588, -3.02182720150686, -3.00827629444882, -2.99415068115602, -2.97944684164863, -2.96416215138963, -2.94829490458789, -2.93184433348009, -2.91481062377897, -2.89719492648594, -2.87899936627017, -2.86022704661464, -2.84088205192119, -2.82096944675395, -2.80049527238261, -2.77946654076565, -2.75789122608936, -2.73577825395256, -2.71313748825975, -2.68997971585895, -2.66631662893452, -2.64216080514184, -2.61752568545007, -2.59242554964213, -2.56687548940832, -2.54089137896207, -2.51448984310361, -2.48768822265975, -2.46050453723595, -2.43295744523009, -2.40506620107533, -2.37685060970248, -2.34833097823895, -2.31952806499184, -2.29046302579587, -2.26115735784182, -2.23163284113799, -2.20191147779342, -2.17201542934874, -2.14196695241518, -2.11178833291631, -2.08150181925743, -2.05112955477553, -2.02069350984688, -1.99021541404895, -1.95971668878924, -1.92921838082421, -1.89874109709786, -1.86830494133059, -1.83792945278543, -1.80763354763046, -1.77743546330356, -1.74735270626836, -1.71740200352924, -1.68759925824835, -1.65795950977936, -1.62849689840169, -1.59922463500461, -1.57015497593506, -1.54129920318451, -1.51266761005108, -1.48426949237217, -1.45611314538148, -1.42820586620258, -1.40055396194899, -1.3731627633591, -1.3460366438533, -1.31917904386017, -1.29259250022016, -1.26627868043712, -1.24023842151345, -1.21447177307062, -1.18897804442671, -1.16375585527447, -1.13880318957874, -1.11411745229096, -1.08969552846035, -1.06553384430817, -1.04162842982115, -1.01797498241485, -0.99456893121627, -0.971405501518116, -0.948479778964027, -0.925786773035745, -0.903321479428376, -0.881078940919099, -0.859054306357351, -0.837242887430199, -0.815640212885347, -0.794242079924886, -0.773044602515721, -0.75204425639646, -0.731237920595468, -0.710622915309609, -0.690197036028111, -0.669958583819721, -0.649906391734187, -0.630039847299913, -0.610358911128643, -0.590864131664546, -0.571556656138833, -0.552438237812407, -0.533511239606931, -0.514778634240093, -0.49624400099335, -0.477911519249705, -0.459785958946509, -0.44187266809257, -0.424177557501669, -0.406707082895245, -0.389468224526356, -0.372468464475371, -0.355715761765006, -0.339218525439597, -0.32298558575021, -0.307026163584093, -0.291349838274449, -0.275966513924366, -0.260886384377309, -0.24611989696612, -0.231677715172769, -0.217570680332256, -0.20380977251621, -0.190406070734422, -0.177370712596171, -0.164714853576943, -0.152449626040639, -0.140586098171668, -0.129135232975708, -0.118107847512096, -0.107514572524408, -0.0973658126388723, -0.087671707302487, -0.0784420926339291, -0.0696864643606103, -0.0614139420140957, -0.0536332345539109, -0.0463526075860005, -0.039579852337156, -0.0333222565402635, -0.0275865773774662, -0.022379016619199, -0.0177051980866586, -0.0135701475536346, -0.00997827519080966, -0.00693336064190478, -0.00443854080613063, -0.00249630038595095, -0.00110846524259226, -0.000276198584961226]
DN_Ansys_k05rog_0 = [-0.000795287196063071, -0.00390845911489791, -0.00933977970240808, -0.0170902179714718, -0.0271614584264906, -0.0395559130297653, -0.054276734767971, -0.0713278329057396, -0.0907138900414236, -0.112440381106338, -0.13651359447386, -0.16294065536759, -0.191729551778941, -0.222889163123425, -0.256429291881747, -0.292360698486425, -0.330695139727176, -0.371445410958948, -0.414625392404987, -0.460250099854678, -0.508335740061504, -0.55889977115143, -0.611960968356294, -0.667539495391053, -0.725656981798481, -0.786336606590629, -0.849603188524015, -0.915483283355226, -0.984005288436989, -1.05519955503166, -1.12909850874136, -1.20573677848172, -1.28515133446113, -1.36738163567019, -1.45246978743817, -1.54046070967581, -1.63140231649861, -1.72534570801267, -1.82234537514923, -1.92245941855453, -2.02574978268276, -2.13228250640252, -2.24212799161541, -2.35536129160231, -2.47206242106202, -2.59231669009419, -2.71621506470763, -2.8438545568142, -2.97533864710464, -3.11077774470488, -3.25028968809103, -3.39400029241163, -3.54204394914292, -3.69456428490523, -3.85171488732217, -4.01366010703426, -4.18057594642386, -4.35265104730904, -4.53008779187529, -4.71310353350168, -4.90193197698338, -5.09682473105975, -5.29805306025436, -5.5059098679843, -5.720711948908, -5.94280255581782, -6.17255433538719, -6.41037269819066, -6.65669970220304, -6.91201854620155, -7.17685879113604, -7.4518024549197, -7.73749116100334, -8.03463456594083, -8.3440203492291, -8.666526124577, -9.00313373180086, -9.35494650178716, -9.72321026633538, -10.109339128976, -10.5149473497296, -10.9418891676753, -11.3923090532648, -11.8687058455558, -12.3740156432441, -12.9117204342608, -13.4859926851436, -14.1018911833576, -14.7656315938175, -15.484968757065, -16.269751096168, -17.1327493182947, -18.0909401651206, -19.1675821034241, -20.3957518516557, -21.8247779146599, -23.5329777328925, -25.6559182149573, -28.4602119081292, -32.5922924814771, -40.3969893365013, -43.5049729448992, -33.9048581588742, -29.3031078207675, -26.3052161473781, -24.0849679115682, -22.3238935491994, -20.8660797391778, -19.6236214405039, -18.5420860440027, -17.5854314816555, -16.7285594655186, -15.9532918047472, -15.2460404858588, -14.596382330157, -13.9961471420448, -13.4388122742947, -12.919087828007, -12.4326247234225, -11.9758044087832, -11.5455842624827, -11.1393818792844, -10.7549870665803, -10.3904939514318, -10.0442479239787, -9.71480368883223, -9.40089174499637, -9.10139133956901, -8.81530844951562, -8.54175770879699, -8.27994746058672, -8.02916730651187, -7.78877766726706, -7.55820097564031, -7.33691420372714, -7.12444248779005, -6.92035366175936, -6.72425354731564, -6.53578187742684, -6.35460875303819, -6.18043155074197, -6.01297221374719, -5.85197487012408, -5.69720373172625, -5.54844123485856, -5.40548639002443, -5.26815331323025, -5.13626991556815, -5.00967673131241, -4.88822586768719, -4.77178006190191, -4.66021183309294, -4.55340271852611, -4.45124258486077, -4.35362900649833, -4.26046670407412, -4.171667037032, -4.08714754497142, -4.00683153309754, -3.9306476976543, -3.8585297876922, -3.79041629992915, -3.72625020381409, -3.66597869420822, -3.60955296936442, -3.55692803211771, -3.50806251240429, -3.46291850940738, -3.42146145178936, -3.3836599746137, -3.34948581169114, -3.31891370220299, -3.29192131056415, -3.26848915858986, -3.24860056912534, -3.23224162038781, -3.21940111035661, -3.21007053063036, -3.20424404925134, -3.20191850207751, -3.20309339236118, -3.20777089827336, -3.21595588819199, -3.22765594365337, -3.24288138994885, -3.26164533443313, -3.28396371269824, -3.30985534285797, -3.33934198828205, -3.37244842921867, -3.40920254384883, -3.44963539942645, -3.49378135427674, -3.54167817155185, -3.59336714577879, -3.64889324338277, -3.70830525852946, -3.77165598580607, -3.83900241145485, -3.9104059250875, -3.98593255404802, -4.06565322285921, -4.14964404048912, -4.2379866185142, -4.33076842364291, -4.42808316850504, -4.53003124511832, -4.63672020602723, -4.74826529878255, -4.86479006021381, -4.98642697785789, -5.11331822697543, -5.24561649283936, -5.38348588945791, -5.52710298764272, -5.67665796740982, -5.83235591217797, -5.9944182651942, -6.16308447218171, -6.33861383850955, -6.52128763440418, -6.71141148808358, -6.90931811448288, -7.11537043682595, -7.32996517015792, -7.55353695071525, -7.78656311349179, -8.02956924365043, -8.28313565698046, -8.54790500236774, -8.82459122788655, -9.11399021528976, -9.41699247043221, -9.73459836661879, -10.067936584113, -10.4182865865918, -10.7871062453526, -11.1760660959133, -11.5870922364454, -12.0224206254612, -12.484666620073, -12.9769151957232, -13.5028396969052, -14.0668606772962, -14.6743622433786, -15.3319928241364, -16.0480932294284, -16.8333225730553, -17.7016028910678, -18.671599013638, -19.7691435586223, -21.0314357645529, -22.5148326951236, -24.3106619045151, -26.5814325970917, -29.6592205585781, -34.3889598689265, -43.1781664374437, -38.6219497756729, -31.9744347454127, -28.1173472749423, -25.4313476522447, -23.3740881114844, -21.7078411846458, -20.3080881771494, -19.1016205211921, -18.0417900270321, -17.0970592059508, -16.2451158131921, -15.4695966069502, -14.7581460931714, -14.1012069903886, -13.4912347787999, -12.9221696570692, -12.3890709347508, -11.8878573899822, -11.4151187664628, -10.96797624125, -10.5439773553896, -10.1410156774217, -9.75726853052693, -9.3911481219166, -9.04126275862752, -8.70638575315396, -8.38543026145648, -8.07742874735282, -7.78151609089386, -7.49691559340185, -7.2229273047395, -6.95891822699477, -6.70431404546853, -6.45859211127873, -6.22127545616543, -5.9919276635766, -5.7701484540094, -5.5555698691969, -5.34785296077949, -5.14668490586233, -4.95177648529372, -4.76285987133267, -4.57968668016145, -4.40202625186734, -4.22966412639735, -4.06240068883718, -3.90004996138238, -3.74243852271487, -3.58940453829602, -3.44079688743979, -3.29647437501449, -3.15630501730552, -3.02016539300361, -2.88794005150799, -2.75952097178334, -2.63480706591338, -2.51370372227316, -2.39612238391773, -2.28198015836947, -2.17119945549579, -2.06370765061105, -1.95943677032277, -1.85832319897747, -1.76030740385451, -1.66533367751041, -1.5733498958972, -1.48430729106931, -1.39816023745863, -1.31486605083891, -1.23438479922109, -1.15667912502372, -1.08171407794829, -1.0094569580602, -0.93987716863452, -0.872946078372187, -0.808636892629132, -0.746924533328577, -0.68778552724741, -0.631197902381336, -0.577141092102379, -0.525595846826488, -0.476544152909918, -0.429969158491351, -0.385855105992952, -0.344187270989163, -0.304951907146566, -0.268136196933342, -0.233728207792493, -0.201716853469672, -0.172091860184918, -0.144843737337771, -0.119963752437558, -0.0974439099553753, -0.0772769338016147, -0.0594562531426337, -0.0439759912826421, -0.0308309573521502, -0.0200166405616466, -0.0115292067996465, -0.00536549737607456, -0.00152302973668446]
class RCSCalculator:
    def __init__(self, k0=4*math.pi, toch=20, n=4, phi=1*math.pi/2, a=None, eps=None, miy=None, k1=None):
        """
        Инициализация калькулятора RCS
        max k0=100000, toch=93
        Параметры:
        k0 - волновое число
        toch - количество учитываемых членов ряда
        n - число слоев (последний слой - воздух)
        phi - азимутальный угол (по умолчанию pi)
        a, eps, miy - параметры слоев (радиусы, диэлектрические проницаемости, магнитные проницаемости)
        """
        if k1 == None: self.k1=k0 
        else: self.k1 = k1 
        self.k0 = k0
        self.toch = toch
        self.n = n
        self.phi = phi
        
        # Параметры материалов по умолчанию (3 слоя)
        self.a = a if a is not None else [0.53, 0.75, 0.93, 1]
        self.eps = eps if eps is not None else [1.86, 1.57, 1.28, 1]
        # 3.48 -0.0037j 0.55
        #a = [0.53, 0.75, 0.93, 1] [0.001,  0.05, 1]
        #eps = [1.86, 1.57, 1.28, 1]  [10e20-10e10j, 3.48 -0.0037j, 1]
        self.miy = miy if miy is not None else [1, 1, 1, 1]
        
        # Инициализация всех необходимых массивов
        self._initialize_arrays()
        
    def _initialize_arrays(self):
        """Инициализация всех массивов и переменных"""
        # Углы для расчета
        self.teta_start = 0.01
        self.teta_stop = 360
        self.step = math.pi/180
        self.teta_diap = abs(self.teta_stop) - abs(self.teta_start)
        self.steps = int(((self.teta_diap * (math.pi/180)) / self.step)) + 1
        self.teta = np.zeros(int(self.steps))
        self.cos_teta = np.zeros(int(self.steps))
        
        # Переменные среды
        self.alfa = np.zeros(self.n, dtype=complex)
        self.beta = np.zeros(self.n, dtype=complex)
        self.sigma = np.zeros(self.n, dtype=complex)
        self.k = np.zeros((self.n, self.n), dtype=complex)
        
        # Функции Бесселя, Неймана и др.
        self.J = np.zeros(self.toch, dtype=complex)
        self.Jpr = np.zeros(self.toch, dtype=complex)
        self.N = np.zeros(self.toch, dtype=complex)
        self.Npr = np.zeros(self.toch, dtype=complex)
        self.C = np.zeros((self.toch, len(self.sigma)-1), dtype=complex)
        self.Cpr = np.zeros((self.toch, len(self.sigma)-1), dtype=complex)
        self.S = np.zeros((self.toch, len(self.sigma)-1), dtype=complex)
        self.Spr = np.zeros((self.toch, len(self.sigma)-1), dtype=complex)
        
        # Импедансы и адмитансы
        self.Z = np.zeros((self.toch, len(self.a)), dtype=complex)
        self.Y = np.zeros((self.toch, len(self.a)), dtype=complex)
        
        # Модифицированные функции
        self.mJ = np.zeros(self.toch, dtype=complex)
        self.mJpr = np.zeros(self.toch, dtype=complex)
        self.mH = np.zeros(self.toch, dtype=complex)
        self.mHpr = np.zeros(self.toch, dtype=complex)
        
        # Коэффициенты рассеяния
        self.Mn = np.zeros(self.toch, dtype=complex)
        self.Nn = np.zeros(self.toch, dtype=complex)
        
        # Поля
        self.E_kp = np.zeros((self.toch, self.steps), dtype=complex)
        self.E_op = np.zeros((self.toch, self.steps), dtype=complex)
        self.S_teta = np.zeros((self.toch, self.steps), dtype=complex)
        self.S_phi = np.zeros((self.toch, self.steps), dtype=complex)
        self.E_teta = np.zeros((1, self.steps), dtype=complex)
        self.E_phi = np.zeros((1, self.steps), dtype=complex)
        
    def calculate_medium_parameters(self):
        """Расчет параметров среды"""
        for i in range(self.n):
            self.alfa[i] = cmath.atan(self.eps[i].imag / self.eps[i].real) if self.eps[i].real != 0 else math.pi/2
            self.beta[i] = math.atan(self.miy[i].imag / self.miy[i].real)
            self.sigma[i] = cmath.sqrt(abs(self.eps[i]) * abs(self.miy[i]))
            if self.eps[-1] != len(self.eps) - 1:
                self.alfa = np.append(self.alfa, 0)
                self.eps = np.append(self.eps, len(self.eps))
    
    def calculate_k_coefficients(self):
        """Расчет коэффициентов k"""
        j = 0
        for i in range(self.n):
            self.k[i][j] = self.k0 * self.a[i] * self.sigma[j]
            if j < self.n - 1:
                j += 1
                self.k[i][j] = self.k0 * self.a[i] * self.sigma[j]

    def Jfunc(self, i, j1, j2):
        """Функция Бесселя первого рода"""
        nu = i + 1
        J = (scipy.special.jv(nu + 0.5, self.k[j1][j2])) * (cmath.sqrt(self.k[j1][j2] * math.pi/2))
        return J
    
    def Jprfunc(self, i, j1, j2, tie):
        """Производная функции Бесселя первого рода"""
        nu = i + 1

        if tie == False:
            Jpr = ((nu / (2 * nu + 1)) *  (scipy.special.jv(nu - 0.5, self.k[j1][j2]) * cmath.sqrt(self.k[j1][j2] * math.pi/2)) - \
            ((nu + 1) / (2 * nu + 1)) *  (scipy.special.jv(nu + 1.5, self.k[j1][j2]) * cmath.sqrt(self.k[j1][j2] * math.pi/2)) + \
            (self.J[i] / self.k[j1][j2]))
        else:
            Jpr = ((nu / (2 * nu + 1)) * ((scipy.special.jv(nu - 0.5,self.k[j1][j2]) * (cmath.sqrt(self.k[j1][j2] * math.pi/2))) / self.k[j1][j2])) * self.k[j1][j2] - \
            (((nu + 1) / (2 * nu + 1)) * ((scipy.special.jv(nu + 1.5,self.k[j1][j2])) * (cmath.sqrt(self.k[j1][j2] * math.pi/2))) / self.k[j1][j2]) * self.k[j1][j2] + \
            ((scipy.special.jv(nu + 0.5,self.k[j1][j2])) * (cmath.sqrt(self.k[j1][j2] * math.pi/2))) / self.k[j1][j2]
        return Jpr
    
    def Nfunc(self, i, j1, j2):
        """Функция Неймана"""
        return scipy.special.yv((i+1) + 0.5, self.k[j1][j2]) * cmath.sqrt(self.k[j1][j2] * math.pi/2)
    
    def Nprfunc(self, i, j1, j2, tie):
        """Производная функции Неймана"""
        nu = i + 1
        if not tie:
            return ((nu / (2 * nu + 1)) * scipy.special.yv(nu - 0.5, self.k[j1][j2]) * cmath.sqrt(self.k[j1][j2] * math.pi/2) -
                   ((nu + 1) / (2 * nu + 1)) * scipy.special.yv(nu + 1.5, self.k[j1][j2]) * cmath.sqrt(self.k[j1][j2] * math.pi/2) +
                   (self.Nfunc(i, j1, j2) / self.k[j1][j2]))
        else:
            return ((nu / (2 * nu + 1)) * (scipy.special.yv(nu - 0.5, self.k[j1][j2]) * cmath.sqrt(self.k[j1][j2] * math.pi/2) / self.k[j1][j2]) * self.k[j1][j2] -
                   ((nu + 1) / (2 * nu + 1)) * (scipy.special.yv(nu + 1.5, self.k[j1][j2]) * cmath.sqrt(self.k[j1][j2] * math.pi/2) / self.k[j1][j2]) * self.k[j1][j2] +
                   (self.Nfunc(i, j1, j2) / self.k[j1][j2]))
    
    def calculate_bessel_functions(self):
        """Расчет функций Бесселя и Неймана"""
        for i in range(self.toch):
            self.J[i] = self.Jfunc(i, 0, 0)
            self.Jpr[i] = self.Jprfunc(i, 0, 0, False)
            self.N[i] = self.Nfunc(i, 0, 0)
            self.Npr[i] = self.Nprfunc(i, 0, 0, False)
    def calculate_CS_functions(self):
        """Расчет функций C, S и их производных"""
        for i in range(self.toch):
            for j in range(len(self.sigma)-1):
                self.C[i][j] = (self.Jfunc(i, j+1, j+1) * self.Nprfunc(i, j, j+1, True) - 
                               self.Nfunc(i, j+1, j+1) * self.Jprfunc(i, j, j+1, True))
                self.Cpr[i][j] = (self.Jprfunc(i, j+1, j+1, True) * self.Nprfunc(i, j, j+1, True) - 
                                 self.Nprfunc(i, j+1, j+1, True) * self.Jprfunc(i, j, j+1, True))
                self.S[i][j] = (self.Nfunc(i, j+1, j+1) * self.Jfunc(i, j, j+1) - 
                               self.Jfunc(i, j+1, j+1) * self.Nfunc(i, j, j+1))
                self.Spr[i][j] = (self.Nprfunc(i, j+1, j+1, True) * self.Jfunc(i, j, j+1) - 
                                 self.Jprfunc(i, j+1, j+1, True) * self.Nfunc(i, j, j+1))
    def calculate_impedances(self):
        """Расчет импедансов и адмитансов"""
        for i in range(self.toch - 1):
            for h in range(len(self.a)):
                if h == 0:
                    numerator = cmath.exp(self.alfa[1] * 1j) * abs(self.eps[1])
                    denominator = cmath.exp(self.alfa[0] * 1j) * abs(self.eps[0])
                    self.Z[i][h] = cmath.sqrt(numerator / denominator) * (self.Jpr[i] / self.J[i])
                    numerator = cmath.exp(self.alfa[0] * 1j) * abs(self.eps[0])
                    denominator = cmath.exp(self.alfa[1] * 1j) * abs(self.eps[1])
                    self.Y[i][h] = cmath.sqrt(numerator / denominator) * (self.Jpr[i] / self.J[i])
                    
                
                elif h == (len(self.a) - 1):
                    numerator = cmath.exp(self.alfa[h+1] * 1j) * abs(self.eps[h+1])
                    denominator = cmath.exp(self.alfa[h] * 1j) * abs(self.eps[h])
                    sqrt_part = cmath.sqrt(numerator / denominator) 
                
                    term1 = self.Cpr[i][h-1] + self.Z[i][h-1] * self.Spr[i][h-1]
                    term2 = self.C[i][h-1] + self.Z[i][h-1] * self.S[i][h-1]
                    self.Z[i][h] = sqrt_part * (term1 / term2) 
                
                    numerator = cmath.exp(self.alfa[h] * 1j) * abs(self.eps[h])
                    denominator = cmath.exp(self.alfa[h+1] * 1j) * abs(self.eps[h+1])
                    sqrt_part = cmath.sqrt(numerator / denominator)
                    term1 = self.Cpr[i][h-1] + self.Y[i][h-1] * self.Spr[i][h-1]
                    term2 = self.C[i][h-1] + self.Y[i][h-1] * self.S[i][h-1]
                    self.Y[i][h] = sqrt_part * (term1 / term2) 
                
                else:
                    numerator = cmath.exp(self.alfa[h+1] * 1j) * abs(self.eps[h+1])
                    denominator = cmath.exp(self.alfa[h] * 1j) * abs(self.eps[h])
                    sqrt_part = cmath.sqrt(numerator / denominator)
                
                    term1 = self.Cpr[i][h-1] + self.Z[i][h-1] * self.Spr[i][h-1]
                    term2 = self.C[i][h-1] + self.Z[i][h-1] * self.S[i][h-1]
                    self.Z[i][h] = sqrt_part * (term1 / term2)

                    numerator = cmath.exp(self.alfa[h] * 1j) * abs(self.eps[h])
                    denominator = cmath.exp(self.alfa[h+1] * 1j) * abs(self.eps[h+1])
                    sqrt_part = cmath.sqrt(numerator / denominator)

                    term1 = self.Cpr[i][h-1] + self.Y[i][h-1] * self.Spr[i][h-1]
                    term2 = self.C[i][h-1] + self.Y[i][h-1] * self.S[i][h-1]
                    self.Y[i][h] = sqrt_part * (term1 / term2)
    def Hfunc(self, i, k1):
        """Функция Ханкеля второго рода"""
        nu = i + 1
        H = (scipy.special.hankel1(nu + 0.5,self.k1)) * (cmath.sqrt(self.k1 * math.pi/2))
        return H
    
    def Hprfunc(self, i, k1):
        """Производная функции Ханкеля второго рода"""
        nu = i + 1
        Hpr = ((nu / (2 * nu + 1)) * (((scipy.special.hankel1(nu - 0.5,self.k1) * (cmath.sqrt(self.k1 * math.pi/2))) / self.k1)) * self.k1 - \
        (((nu + 1) / (2 * nu + 1)) * ((scipy.special.hankel1(nu + 1.5,self.k1)) * (cmath.sqrt(self.k1 * math.pi/2))) / self.k1) * self.k1 + \
        ((scipy.special.hankel1(nu + 0.5,self.k1)) * (cmath.sqrt(self.k1 * math.pi/2))) / self.k1)
        return Hpr

    
    def calculate_modified_functions(self):
        """Расчет модифицированных функций"""
        k1 = self.k0
        k00 = self.k[0][0]
        self.k[0][0] = self.k0
        
        for i in range(self.toch):
            self.mJ[i] = self.Jfunc(i, 0, 0)
            self.mJpr[i] = self.Jprfunc(i, 0, 0, True)
            self.mH[i] = self.Hfunc(i, self.k0)
            self.mHpr[i] = self.Hprfunc(i, self.k0)
            
        self.k0 = k1
        self.k[0][0] = k00
    
    def calculate_scattering_coefficients(self):
        """Расчет коэффициентов рассеяния"""
        for i in range(self.toch):
            n = i + 1
            #Элемент Гюгенса дифракция
            #self.Mn[i] = (self.Z[i][self.n-1] * self.mJ[i] - self.mJpr[i]) / (self.Z[i][self.n-1] * self.mH[i] - self.mHpr[i])
            #self.Nn[i] = (self.Y[i][self.n-1] * self.mJ[i] - self.mJpr[i]) / (self.Y[i][self.n-1] * self.mH[i] - self.mHpr[i])
            #Рупор на поверхности сферы
            self.Mn[i] = (self.Z[i][self.n-1]  - 1j) / (self.Z[i][self.n-1] * self.mH[i] - self.mHpr[i])             
            self.Nn[i] = (self.Y[i][self.n-1] - 1j) / (self.Y[i][self.n-1] * self.mH[i] - self.mHpr[i])
            self.Mn[i] = self.Mn[i].real - self.Mn[i].imag * 1j
            self.Nn[i] = self.Nn[i].real - self.Nn[i].imag * 1j
        
    def calculate_angles(self):
        """Расчет углов для диаграммы направленности"""
        for i in range(self.steps):
            if i == 0:
                self.teta[i] = self.teta_start * (math.pi/180)
            else:
                self.teta[i] = self.teta[i-1] + self.step
            self.cos_teta[i] = math.cos(self.teta[i])
    
    def calculate_legendre_functions(self):
        """Расчет функций Лежандра"""
        self.pii = np.zeros((self.toch+1, 2*self.steps+1))
        self.tay = np.zeros((self.toch+1, 2*self.steps+1))
        
        for i in range(self.toch):
            m = i + 1
            M = scipy.special.lpmv(0, m, self.cos_teta)
            Lm0 = M
            M = scipy.special.lpmv(1, m, self.cos_teta)
            Lm1 = M
            
            if m < 2:
                Lm2 = 0
            else:
                M = scipy.special.lpmv(2, m, self.cos_teta)
                Lm2 = M
            
            for z in range(len(self.teta)):
                if (self.teta[z] > 0) and (self.teta[z] < math.pi):
                    self.pii[i][z] = (1 * Lm1[z]) / math.sin(self.teta[z])
                elif (self.teta[z] > math.pi) and (self.teta[z] < 2*math.pi):
                    self.pii[i][z] = (-1 * Lm1[z]) / math.sin(self.teta[z])
            
            for z in range(len(self.teta)):
                if m < 2:
                    self.tay[i][z] = 0.5 * (-m * (m + 1) * Lm0[z])
                else:
                    self.tay[i][z] = 0.5 * (Lm2[z] - m * (m + 1) * Lm0[z])
    
    def calculate_circular_polarization(self):
        """Расчет полей для круговой поляризации"""
        for z in range(len(self.teta)):
            for p in range(self.toch):
                y=p+1
                self.E_op[p][z] = ((2*y + 1) / (y*(y + 1))) * ((-1)**y) * (self.tay[p][z] - self.pii[p][z]) * (self.Mn[p] + self.Nn[p])
                self.E_kp[p][z] = ((2*y + 1) / (y*(y + 1))) * ((-1)**y) * (self.tay[p][z] + self.pii[p][z]) * (self.Mn[p] - self.Nn[p])
        
        self.P1 = np.sum(self.E_op, axis=0)
        self.P2 = np.sum(self.E_kp, axis=0)
        self.Pab1 = np.real(self.P1)
        self.Pab2 = np.real(self.P2)
    
    def calculate_linear_polarization(self):
        """Расчет полей для линейной поляризации"""
        for z in range(len(self.teta)):
            for p in range(self.toch):
                y = p + 1
                #self.S_teta[p][z] = ((2*y + 1)/(y*(y + 1))) * ((-1)**y) * (self.tay[p][z] * self.Mn[p] - self.pii[p][z] * self.Nn[p])
                self.S_teta[p][z] = ((2*y + 1)/(y*(y + 1))) * ((-1)**y) * (-1 * (self.tay[p][z] * self.Mn[p] - self.pii[p][z] * self.Nn[p]) * 
                                     math.cos(self.teta[z]) * math.cos(self.phi)**2 - (self.pii[p][z] * self.Mn[p] - self.tay[p][z] * self.Nn[p]) * 
                                     math.sin(self.phi)**2)
                #self.S_phi[p][z] = ((2*y + 1)/(y*(y + 1))) * ((-1)**y) * (self.tay[p][z] * self.Nn[p] - self.pii[p][z] * self.Mn[p])
                self.S_phi[p][z] = ((2*y + 1)/(y*(y + 1))) * ((-1)**y) * ((self.tay[p][z] * self.Mn[p] - self.pii[p][z] * self.Nn[p]) * 
                                    math.cos(self.phi) * math.sin(self.phi) - (self.pii[p][z] * self.Mn[p] - self.tay[p][z] * self.Nn[p]) * 
                                    math.cos(self.teta[z])**2 * math.sin(self.phi)*math.cos(self.phi))
                self.E_teta[0][z] += self.S_teta[p][z]
                self.E_phi[0][z] += self.S_phi[p][z]
            
            self.E_teta[0][z] = (1 - (math.sin(self.teta[z]) * math.cos(self.phi))**2)**(-0.5) * self.E_teta[0][z]
            self.E_phi[0][z] = (1 - (math.sin(self.teta[z]) * math.cos(self.phi))**2)**(-0.5) * self.E_phi[0][z]

            for p in range(self.toch):
                self.E_teta[0][z] = abs(self.E_teta[0][z])
                self.E_phi[0][z] = abs(self.E_phi[0][z])
    
    def normalize_results(self):
        """Нормализация результатов"""
        self.tetay = np.zeros(self.steps)
        
        for i in range(self.steps):
            self.teta[i] = self.teta[i] 
        
        for i in range(len(self.teta)):
            self.tetay[i] = (self.teta[i] * (self.steps / (2 * math.pi)))
        
        # Нормированные E к k0a
        self.DN_NORM_lin_k0a_teta = self.E_teta[0] / self.k0
        self.DN_NORM_lin_k0a_phi = self.E_phi[0] / self.k0
        self.DN_NORM_circle_k0a_op = self.Pab1 / self.k0
        self.DN_NORM_circle_k0a_kp = self.Pab2 / self.k0
        
        # Нормированные E dB
        E_teta_max = np.max(self.E_teta[0])
        E_phi_max = np.max(self.E_phi[0])
        Pab1_max = np.max(self.Pab1)
        Pab2_max = np.max(self.Pab2)
        
        self.DN_NORM_lin_dB_teta = 20 * np.log10(self.E_teta[0] / E_teta_max)
        self.DN_NORM_lin_dB_phi = 20 * np.log10(self.E_phi[0] / E_phi_max)
        self.DN_NORM_circle_dB_op = 20 * np.log10(self.Pab1 / Pab1_max)
        self.DN_NORM_circle_dB_kp = 20 * np.log10(self.Pab2 / Pab2_max)
    
 
    
    def run_calculation(self):
        """Выполнение полного расчета"""
        #print('Параметры материалов:')
        #print(f'\na = {self.a}\neps = {self.eps}\nmiy = {self.miy}')
        
        self.calculate_medium_parameters()
        self.calculate_k_coefficients()
        self.calculate_bessel_functions()
        self.calculate_CS_functions()
        # Добавляем последний элемент в alfa и eps если нужно
        if self.eps[len(self.eps)-1] != (len(self.eps)-1):
            self.alfa = np.append(self.alfa, 0)
            self.eps = np.append(self.eps, len(self.eps))
        
        self.calculate_impedances()
        self.calculate_modified_functions()
        self.calculate_scattering_coefficients()
        self.calculate_angles()
        self.calculate_legendre_functions()
        self.calculate_circular_polarization()
        self.calculate_linear_polarization()
        self.normalize_results()

#####################
# СРАВНЕНИЕ С ANSYS #
#####################

class ResultPlotter:
    def __init__(self, comp, theta, E1, E2):
        """
        Инициализация класса.
        :param theta: Массив углов в градусах (0-360).
        :param E1: Массив значений E1.
        :param E2: Массив значений E2.
        """
        if comp == 1*math.pi/2:
            self.comp = r'$_\phi$'
        else:
            self.comp = r'$_\theta$'
            
        self.theta = np.array(theta)
        self.E1 = (np.array(E1))
        self.E2 = (np.array(E2))
        if np.min(self.E1+self.E2) > -60: self.Ymin = np.min(self.E1+self.E2)
        else: self.Ymin = -60
        #self.Ymin = np.min(self.E1+self.E2)
        self.Ymax = np.max(self.E1)
        # Сдвигаем массивы на 180 элементов
        #self.E1_shifted = np.roll(self.E1, 180)
        self.E1_shifted = (self.E1)
        #self.E2_shifted = np.roll(self.E2, 180)
        self.E2_shifted = (self.E2)
        # Создаем маску для области в пределах -3 дБ от максимума E1
        E1_max = np.max(self.E1_shifted)
        self.valid_mask = self.E1_shifted >= (E1_max - 3)
        self.squared_errors = np.zeros_like(self.E1_shifted)
        self.squared_errors3 = np.zeros_like(self.E1_shifted)
        self.squared_errors[self.valid_mask] = np.sqrt((self.E1_shifted[self.valid_mask] - self.E2_shifted[self.valid_mask]) ** 2)
        self.squared_errors3 = np.sqrt(abs((self.E1_shifted - self.E2_shifted) ** 2))
        # Среднеквадратичная ошибка только для валидной области
        self.mseMax = np.mean(self.squared_errors3)
        self.mse = np.mean(self.squared_errors[self.valid_mask]) if np.any(self.valid_mask) else 0
        # Вычисляем корреляцию Пирсона только для валидной области
        self.pearson_corr = 0
        self.regression_line = None
        

    def calc_pearson_correlation(self):
        """Вычисление корреляции Пирсона между E1 и E2 в валидной области."""
        if not np.any(self.valid_mask):
            return
        
        # Выбираем данные из валидной области
        E1_valid = np.real(self.E1_shifted[self.valid_mask])
        E2_valid = np.real(self.E2_shifted[self.valid_mask])
        
        # Вычисляем корреляцию Пирсона
        self.pearson_corr, _ = pearsonr(E1_valid, E2_valid)
        
        # Рассчитываем линию регрессии
        coeffs = np.polyfit(E1_valid, E2_valid, 1)
        self.regression_line = np.poly1d(coeffs)

    def plot_polar(self):
        """Построение полярного графика E1 и E2 (после сдвига)."""
        fig, ax = plt.subplots(figsize=(8, 8), subplot_kw={'projection': 'polar'})
        theta_rad = (self.theta)
        ax.set_ylim(-40, 0)
        # Графики со сдвинутыми данными
        ax.plot(theta_rad, self.E1_shifted, 
                color='#1f77b4', linestyle='--', linewidth=1.5, 
                alpha=0.9, label=r'E$_\theta$($\theta$), дБ')
        ax.plot(theta_rad, self.E2_shifted, 
                color='#ff7f0e', linestyle='-', linewidth=2.5, 
                alpha=0.9, label=r'E$_\varphi$($\theta$), дБ')
        #ax.set_title(f'E{self.comp}, дБ', fontsize=15, pad=20)
        #ax.set_title(r'$k_0a = 0.6, \varepsilon = 78.73 - i \cdot 12.28$', fontsize=14, pad=20)
        ax.legend(loc='best', fontsize=14, frameon=True, framealpha=0.95)
        ax.set_theta_zero_location('E')  # 0° сверху
        ax.set_theta_direction(1)       # По часовой стрелке
        plt.legend(loc='upper right')
        plt.tight_layout()
        ax.text(0,  # 90° 
        ax.get_rmax() +7, r'$\theta$$\degree$', fontsize=14, ha='right', va='center')
        return fig

    def plot_cartesian(self):
        """Декартов график E1 и E2 (после сдвига) для углов 0-180 градусов."""
        fig, ax = plt.subplots(figsize=(8, 6))
        # Маска для углов 0-180
        mask = (self.theta >= 0) & (self.theta <= 180)
        theta_subset = np.degrees(self.theta[mask])
        E1_subset = self.E1_shifted[mask]
        E2_subset = self.E2_shifted[mask]
        
        # Построение графиков
        ax.plot(theta_subset, E1_subset, 
                color='#1f77b4', linestyle='--', linewidth=1.5, 
                alpha=0.9, label='Ansys')
        ax.plot(theta_subset, E2_subset, 
                color='#ff7f0e', linestyle='-', linewidth=2.5, 
                alpha=0.9, label='GreenTensor')
        # Выделение валидной области
        angle_mask = (self.theta >= 0) & (self.theta <= 180)

        valid_mask = self.valid_mask[angle_mask]
        ax.fill_between(theta_subset, -70, 5, 
                        where=valid_mask, color='green', 
                        alpha=0.15, label='Область по уровню -3дБ')
        ax.set_xlim(0, 180)
        ax.set_ylim(self.Ymin, 0)
        ax.set_xlabel(r'$\theta$$\degree$', fontsize=14)
        ax.set_ylabel(f'E{self.comp}, дБ', fontsize=14)
        ax.legend(fontsize=12)
        ax.grid(True)
        # Форматирование осей
        ax.xaxis.set_major_locator(ticker.MultipleLocator(30))
        ax.xaxis.set_minor_locator(ticker.MultipleLocator(15))
        plt.tight_layout()
        plt.legend(loc='upper right')
        return fig

    def plot_error(self):
        fig, ax = plt.subplots(figsize=(8, 6))
        # Маска для углов 0-180
        angle_mask = (self.theta >= 0) & (self.theta <= 180)
        theta_subset = np.degrees(self.theta[angle_mask])
        errors_subset = self.squared_errors[angle_mask]
        
        # Отдельно выделяем валидную область
        valid_mask = self.valid_mask[angle_mask]
        ax.fill_between(theta_subset, np.min(errors_subset), np.max(self.squared_errors3), 
                        where=valid_mask, color='green', 
                        alpha=0.15, label='Область по уровню -3дБ')
        ax.plot(theta_subset, self.squared_errors3, 
                color='#2ca02c', linestyle='-', linewidth=2.5, 
                alpha=0.9, label='Cреднеквадратическая ошибка')
        
        ax.set_xlim(0, 360)
        ax.set_ylim(0)
        ax.set_xlabel(r'$\theta$$\degree$', fontsize=14)
        ax.set_ylabel('Cреднеквадратическая ошибка, дБ', fontsize=14)
        ax.legend(fontsize=12)
        ax.grid(True)
        
        # Форматирование осей
        ax.xaxis.set_major_locator(ticker.MultipleLocator(30))
        ax.xaxis.set_minor_locator(ticker.MultipleLocator(15))
        plt.tight_layout()
        plt.legend(loc='upper right')
        print(f'RMSE(-3dB): {self.mse:.4f}')
        print(f'RMSE: {self.mseMax:.4f}')
        return fig
    
    def plot_pearson_correlation(self):
        self.calc_pearson_correlation()
        """Визуализация корреляции Пирсона в валидной области."""
        if not np.any(self.valid_mask):
            print("No valid data points for correlation analysis")
            return None
        
        fig, ax = plt.subplots(figsize=(8, 8))
        
        # Выбираем данные из валидной области
        E1_valid = self.E1_shifted[self.valid_mask]
        E2_valid = self.E2_shifted[self.valid_mask]
        
        # Создаем scatter plot
        ax.scatter(E1_valid, E2_valid, 
                   color='#1f77b4', alpha=0.7, s=60,
                   label='Точки данных')
        
        # Добавляем линию регрессии
        x_vals = np.linspace(min(E1_valid), max(E1_valid), 100)
        y_vals = self.regression_line(x_vals)
        ax.plot(x_vals, y_vals, 
                color='#d62728', linestyle='--', linewidth=2.5,
                label=f'Линия регрессии: y = {self.regression_line.coeffs[0]:.4f}x + {self.regression_line.coeffs[1]:.4f}')
        
        # Добавляем идеальную линию
        min_val = min(min(E1_valid), min(E2_valid))
        max_val = max(max(E1_valid), max(E2_valid))
        ax.plot([min_val, max_val], [min_val, max_val], 
                color='#2ca02c', linestyle=':', linewidth=2,
                label='Эталонная корреляция (y = x)')
        
        # Настраиваем график
        ax.set_xlabel(f'E{self.comp}, дБ (Ansys)', fontsize=14)
        ax.set_ylabel(f'E{self.comp}, дБ (GreenTensor)', fontsize=14)
        ax.legend(fontsize=12)
        ax.grid(True, alpha=0.3)
        
        # Добавляем аннотацию с коэффициентом корреляции
        ax.annotate(f'r = {self.pearson_corr:.4f}', 
                    xy=(0.05, 0.95), xycoords='axes fraction',
                    fontsize=14, bbox=dict(boxstyle="round,pad=0.3", 
                                           fc="white", ec="gray", alpha=0.8))
        
        # Устанавливаем равные масштабы осей
        ax.set_aspect('equal', adjustable='box')
        plt.legend(loc='upper right')
        plt.tight_layout()
        print(f'Корреляция Пирсона: {self.pearson_corr:.4f}')
        return fig

    def plot_all(self):
        """Построение всех графиков."""
        figs = []
        figs.append(self.plot_polar())
        #figs.append(self.plot_cartesian())
        #figs.append(self.plot_error())
        #figs.append(self.plot_pearson_correlation())
        plt.show()
        return figs


#######################################################
#  #
#######################################################
    
class ScatteringCalculator:
    def __init__(self, tochl=10, k0a_start=0.25, k0a_stop=5.0, k0a_step=0.05):
        """
        Параметры:
            toch: количество членов в разложении
            k0a_start: начальное значение k0a
            k0a_stop: конечное значение k0a
            k0a_step: шаг изменения k0a
        """
        self.toch = tochl
        self.k0a_start = k0a_start
        self.k0a_stop = k0a_stop
        self.k0a_step = k0a_step
        
        # Инициализация массивов коэффициентов
        self.i_arr = np.arange(1, self.toch + 1)  # начинаем с 1 до toch включительно
        self.coeffs_1 = 2 * self.i_arr + 1       # (2n + 1)
        self.coeffs_2 = 2 * (self.i_arr**2) - 1  # (2n² - 1)
        self.coeffs_3 = self.i_arr * (self.i_arr + 1)  # n(n+1)
        self.minus_1_pow = (-1)**self.i_arr
        
        # Создаем экземпляр RCSCalculator
        self.rcs_calculator = RCSCalculator()
    
    def calculate(self):
        """Основной метод расчета"""
        # Генерация массива k0a
        self.k0a = np.arange(self.k0a_start, self.k0a_stop + self.k0a_step/2, self.k0a_step)
        k0a_steps = len(self.k0a)
        
        # Инициализация результирующих массивов
        self.sigma_s = np.zeros(k0a_steps)
        self.sigma_theta = np.zeros(k0a_steps)  
        self.sigma_phi = np.zeros(k0a_steps)
        self.sigma_r = np.zeros(k0a_steps)
        self.sigma_p = np.zeros(k0a_steps)
        
        for k, current_k0a in enumerate(self.k0a):
            self._calculate_for_k(k, current_k0a)
        
        return self.k0a, self.sigma_s, self.sigma_r, self.sigma_p, self.sigma_theta, self.sigma_phi
    
    def _calculate_for_k(self, k, current_k0a):
        """Вычисления для конкретного значения k0a"""
        self.rcs_calculator.k0 = current_k0a
        self.rcs_calculator.run_calculation()
        
        Mn = self.rcs_calculator.Mn
        Nn = self.rcs_calculator.Nn
        
        abs_Mn_sq = np.abs(Mn)**2
        abs_Nn_sq = np.abs(Nn)**2
        
        # Вычисление сумм
        sum_sigma_1 = np.sum(self.coeffs_1 * (abs_Mn_sq + abs_Nn_sq))
        sum_sigma_2 = np.sum(self.coeffs_1 * self.minus_1_pow * (Mn - Nn))
        sum_sigma_3 = np.sum(self.coeffs_1 * (Mn + Nn))
        sum_sigma_4 = np.sum((self.coeffs_1/self.coeffs_3)*(self.coeffs_2 * abs_Mn_sq + self.coeffs_1 * abs_Nn_sq))
        sum_sigma_5 = np.sum((self.coeffs_1/self.coeffs_3) * (self.coeffs_2 * abs_Nn_sq + self.coeffs_1 * abs_Mn_sq))
        
        k0a_sq = current_k0a**2
        self.sigma_s[k] = (2 / k0a_sq) * sum_sigma_1
        self.sigma_r[k] = (1 / k0a_sq) * np.abs(sum_sigma_2)**2
        self.sigma_p[k] = (1 / k0a_sq) * np.abs(sum_sigma_3)**2
        self.sigma_theta[k] = (1 / k0a_sq) * sum_sigma_4
        self.sigma_phi[k] = (1 / k0a_sq) * sum_sigma_5
    #  r'$E_{\theta}$'
    def plot_results(self):
        """Визуализация результатов в трех отдельных графиках"""
        plt.figure(figsize=(12, 10))
    
        # Первый график - σ_s и компоненты
        plt.subplot(3, 1, 1)
        plt.plot(self.k0a, self.sigma_s, 'b-', label= r'${\sigma}_{s}$')
        plt.plot(self.k0a, self.sigma_theta, 'r--', label= r'${\sigma}_{\theta}$')
        plt.plot(self.k0a, self.sigma_phi, 'g--', label= r'${\sigma}_{\phi}$')
        plt.title('Полный коэффициент рассеяния')
        plt.xlabel('k0a')
        plt.ylabel(r'${\sigma}$')
        plt.grid(True)
        plt.legend()
        
        # Второй график - σ_r
        plt.subplot(3, 1, 2)
        plt.plot(self.k0a, self.sigma_r, 'm-', label= r'${\sigma}_{r}$')
        plt.title('Радиолокационный коэффициент рассеяния')
        plt.xlabel('k0a')
        plt.grid(True)
        plt.legend()
        
        # Третий график - σ_p
        plt.subplot(3, 1, 3)
        plt.plot(self.k0a, self.sigma_p, 'c-', label= r'${\sigma}_{p}$')
        plt.title('Коэффициент рассеяния в попутном направлении')
        plt.xlabel('k0a')
        plt.grid(True)
        plt.legend()
        
        plt.tight_layout()
        plt.show()


############################
# ПОСТРОЕНИЕ ТЕПЛОВЫХ КАРТ #
############################
        

class ParameterSweep:
    def __init__(self, simulation_class, k0_start, k0_stop, k0_step, phi0):
        """
        Класс для параметрического анализа по волновому числу k0.
        
        :param simulation_class: Класс для моделирования (должен иметь метод run и поле E)
        :param k0_start: Начальное значение k0
        :param k0_stop: Конечное значение k0
        :param k0_step: Шаг изменения k0
        :param phi0: Фиксированное значение угла phi0
        """
        self.simulation_class = simulation_class
        self.k0_start = k0_start
        self.k0_stop = k0_stop
        self.k0_step = k0_step
        self.phi0 = (phi0)
        self.k0_values = None
        self.results = None

    def run_sweep(self):
        """Выполнить цикл по k0 и собрать результаты."""
        n_points = int(np.ceil((self.k0_stop - self.k0_start) / self.k0_step)) + 1
        self.k0_values = np.linspace(self.k0_start, self.k0_stop, n_points)
        self.results = []
        
        for k0 in self.k0_values:
            # Создаем новый экземпляр класса для каждого k0
            sim = self.simulation_class(k1=k0, phi=self.phi0)
            sim.run_calculation()  # Запускаем расчет
            
            # Получаем и проверяем поле E
            e_field = (np.real(sim.DN_NORM_lin_k0a_teta))
            self.results.append(e_field)
            print(self.phi0)
        
        # Преобразуем результаты в массив (k0 x углы)
        self.results = np.array(self.results)

    def plot_heatmap(self, output_file='heatmap.png'):
        """Построить тепловую карту в полярных координатах."""
        if self.results is None:
            raise RuntimeError("Сначала выполните run_sweep()")
        
        # Создаем полярную сетку
        theta = np.radians(np.linspace(0, 359, 360))  # Углы в радианах (361 точка для замкнутой сетки)
        r = self.k0_values  # Радиусы = значения k0
        
        # Создаем 2D сетку для pcolormesh
        R, Theta = np.meshgrid(r, theta)
        
        # Транспонируем результаты для соответствия размерности сетки
        data = self.results.T  # Теперь форма: (углы x k0)
        
        # Создаем график
        fig, ax = plt.subplots(subplot_kw={'projection': 'polar'}, figsize=(10, 8))
        
        # Построение тепловой карты
        pc = ax.pcolormesh(Theta, R, data, shading='auto', cmap='turbo', vmin=0, vmax=10)
        
        # Настройка внешнего вида
        ax.set_theta_zero_location('E')  # 0° наверху (север)
        ax.set_theta_direction(1)       # По часовой стрелке
        #plt.title(f'Тепловая карта (φ={np.degrees(self.phi0):f} град.)')
        fig.colorbar(pc, ax=ax, label=r'E$_\varphi$, нормированное к $k_0a$')
        
        plt.savefig(output_file, dpi=300, bbox_inches='tight')
        #plt.close(fig)

#######################################################
# СРАВНЕНИЕ ДИАГРАММ НАПРАВЛЕННОСТЕЙ С МЕНЯЮЩИМСЯ k0a #
#######################################################
        
class RCSVariation:
    def __init__(self, k0_start, k0_stop, step, toch=10, n=3, phi=0.0, a=None, eps=None, miy=None, k1=None):
        """
        Инициализация параметров для вариационного анализа.
        
        :param k0_start: Начальное значение k0
        :param k0_stop: Конечное значение k0
        :param step: Шаг изменения k0
        :param toch: Размер сетки (по умолчанию 20)
        :param n: Порядок аппроксимации (по умолчанию 4)
        :param phi: Угол падения в радианах (по умолчанию 0.0)
        :param a, eps, miy, k1: Дополнительные параметры для RCSCalculator
        """
        self.k0_start = k0_start
        self.k0_stop = k0_stop
        self.step = step
        self.toch = toch
        self.n = n
        self.phi = phi
        self.a = a
        self.eps = eps
        self.miy = miy
        self.k1 = None
        self.results = []  # Список для хранения результатов 
        self.k0_values = []  # Список использованных значений k0
        
    def run_calculations(self):
        """Выполняет цикл расчетов для диапазона k0."""
        k0_range = np.arange(self.k0_start, self.k0_stop + self.step, self.step)
        
        for k0 in k0_range:
            # Создаем экземпляр калькулятора с текущим k0
            calculator = RCSCalculator(
                k1=k0,
                toch=self.toch,
                n=self.n,
                phi=self.phi,
                a=self.a,
                eps=self.eps,
                miy=self.miy
            )
            # Сохраняем значение k0
            self.k0_values.append(k0)
            calculator.run_calculation()
            # Сохраняем результат расчета 
            self.results.append(np.roll(np.abs(calculator.DN_NORM_lin_k0a_teta), 180))

    def plot_polar(self):
        """Строит полярный график для всех результатов."""
        plt.figure(figsize=(10, 10))
        ax = plt.subplot(111, projection='polar')
        # Углы в градусах (0-359) -> радианы
        theta = np.deg2rad(np.arange(0, 360))
        #plt.ylim(0, 0.4)
        # Рисуем каждый результат
        for i, result in enumerate(self.results):
            ax.plot(theta, result, label=r'$k_0a$'+f'={self.k0_values[i]:.1f}')
        
        # Настройка графика
        ax.set_theta_zero_location('N')  # 0° наверху
        ax.set_theta_direction(-1)      # По часовой стрелке
        ax.set_title(r'F$_\varphi$, $\varphi$ = 0$\degree$', pad=20, fontsize=20)
        ax.set_theta_zero_location('E')
        ax.set_theta_direction(1)
        ax.text(0,  # 90° 
        ax.get_rmax() +.01, r'$\theta$$\degree$', fontsize=20, ha='right', va='center')
        ax.legend(loc='upper right', bbox_to_anchor=(1.2, 1.1), fontsize=18)
        
        plt.tight_layout()
        plt.show()

if __name__ == "__main__":
    # Создание экземпляров
    #scattering_calc = ScatteringCalculator()
    k0=4*math.pi
    toch=90
    n=4
    phi2=1*math.pi/2
    phi1=0*math.pi/2
    a=None
    eps=None
    miy=None
    k1=k0
    rcs_calc1 = RCSCalculator(k0, toch, n, phi1, a, eps, miy, k1=1*k0)
    rcs_calc2 = RCSCalculator(k0, toch, n, phi2, a, eps, miy, k1=1*k0)
    
    # Выполнение расчетов
    #results = scattering_calc.calculate()
    
    # Визуализация результатов
    #scattering_calc.plot_results()
    # Выполнение расчетов для RCSCalculator

    rcs_calc1.run_calculation()
    rcs_calc2.run_calculation()

    theta = rcs_calc1.teta
    labl = rcs_calc1.phi
    #E1 = DN_Ansys_k05_90
    E1 = rcs_calc1.DN_NORM_lin_dB_teta
    E2 = rcs_calc2.DN_NORM_lin_dB_teta
    # Создание экземпляра класса и построение графиков
    #1 - phi, 0 - theta
    plotter = ResultPlotter(labl, theta, E1, E2)
    plotter.plot_all()
    # Параметры анализа
    k0_start = 0.000001  
    k0_stop = 20
    k0_step = math.pi/10  
    phi0 = 0*np.pi/2

    polar = RCSVariation(k0_start = 0.25, k0_stop = .75, step = 0.25, toch=20, n=4, phi=0*math.pi/2, a=None, eps=None, miy=None, k1=None)
    polar.run_calculations()
    polar.plot_polar()
    # Создание и запуск анализа
    sweep = ParameterSweep(
        simulation_class=RCSCalculator,
        k0_start=k0_start,
        k0_stop=k0_stop,
        k0_step=k0_step,
        phi0=phi0
    )
    for phi0 in np.arange((np.pi)/4, (np.pi)/2, (np.pi)/4):
        sweep = ParameterSweep(
        simulation_class=RCSCalculator,
        k0_start=k0_start,
        k0_stop=k0_stop,
        k0_step=k0_step,
        phi0=phi0
        )
        sweep.run_sweep()
        sweep.plot_heatmap(output_file=f'φ0{phi0:f}k0_sweep_heatmap.png')
    #animate = Phi0SweepAnimation(simulation_class=RCSCalculator, k0_start=k0_start, k0_stop=k0_stop, k0_step=k0_step, phi0_start=0, phi0_stop=180, phi0_step=5)
    #animate.create_animation()